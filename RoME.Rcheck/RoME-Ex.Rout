
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "RoME"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "RoME-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('RoME')
Loading required package: timeDate
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("DataTargetSpecies")
> ### * DataTargetSpecies
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: DataTargetSpecies
> ### Title: Length and weight ranges
> ### Aliases: DataTargetSpecies
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(DataTargetSpecies)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("DataTargetSpecies", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Maturity_parameters")
> ### * Maturity_parameters
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Maturity_parameters
> ### Title: Maturity parameters
> ### Aliases: Maturity_parameters
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(Maturity_parameters)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Maturity_parameters", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("TM_list")
> ### * TM_list
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: TM_list
> ### Title: TM list
> ### Aliases: TM_list
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(TM_list)
> ## maybe str(TM_list) ; plot(TM_list) ...
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("TM_list", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("assTL")
> ### * assTL
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: assTL
> ### Title: TL association between categories and sub-categories
> ### Aliases: assTL
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(assTL)
> ## maybe str(assTL) ; plot(assTL) ...
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("assTL", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("check_0_fieldsTA")
> ### * check_0_fieldsTA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_0_fieldsTA
> ### Title: Checks the presence of 0 fields in TA
> ### Aliases: check_0_fieldsTA
> ### Keywords: error
> 
> ### ** Examples
> 
> library(MEDITS)
> wd <- tempdir()
> suffix <- "27-02-2020 18:30"
> check_0_fieldsTA(MEDITS::TA,wd,suffix)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_0_fieldsTA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:MEDITS'

> nameEx("check_area")
> ### * check_area
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_area
> ### Title: Check if TX files have the same area
> ### Aliases: check_area
> ### Keywords: error
> 
> ### ** Examples
> 
>     wd <- tempdir()
>     suffix="27-02-2020 18:30"
>     DataTA = MEDITS::TA
>     DataTB = MEDITS::TB
>     DataTC = MEDITS::TC
>     DataTD = NA
>     DataTE = NA
>     DataTT = NA
>     DataTL = NA
> 
>     check_area(DataTA, DataTB,DataTC,DataTD=NA,DataTT=NA,DataTE=NA,DataTL=NA, wd, suffix)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_area", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("check_associations_category_TL")
> ### * check_associations_category_TL
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_associations_category_TL
> ### Title: Check corretness of TL categories
> ### Aliases: check_associations_category_TL
> ### Keywords: error
> 
> ### ** Examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_associations_category_TL", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("check_bridles_length")
> ### * check_bridles_length
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_bridles_length
> ### Title: check of bridles length correctness
> ### Aliases: check_bridles_length
> ### Keywords: error
> 
> ### ** Examples
> 
> library(MEDITS)
> wd <- tempdir()
> suffix <- "27-02-2020 18:30"
> check_bridles_length(MEDITS::TA, wd, suffix)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_bridles_length", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:MEDITS'

> nameEx("check_consistencyTA_distance")
> ### * check_consistencyTA_distance
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_consistencyTA_distance
> ### Title: Consistency check of distance in TA
> ### Aliases: check_consistencyTA_distance
> ### Keywords: error
> 
> ### ** Examples
> 
> library(MEDITS)
> wd <- tempdir()
> suffix <- "27-02-2020 18:30"
> check_consistencyTA_distance(MEDITS::TA,wd,suffix)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_consistencyTA_distance", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:MEDITS'

> nameEx("check_consistencyTA_duration")
> ### * check_consistencyTA_duration
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_consistencyTA_duration
> ### Title: Consistency check of hauls duration in TA
> ### Aliases: check_consistencyTA_duration
> ### Keywords: error
> 
> ### ** Examples
> 
> library(MEDITS)
> wd <- tempdir()
> suffix <- "27-02-2020 18:30"
> check_consistencyTA_duration(MEDITS::TA,wd,suffix)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_consistencyTA_duration", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:MEDITS'

> nameEx("check_quadrant")
> ### * check_quadrant
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_quadrant
> ### Title: Check start and end quadrant for each haul
> ### Aliases: check_quadrant
> ### Keywords: quadrant
> 
> ### ** Examples
> 
> library(MEDITS)
> library(RoME)
> wd=tempdir()
> suffix= "27-02-2020 18:30"
> check_quadrant(TA,wd,suffix)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_quadrant", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:MEDITS'

> nameEx("check_quasiidentical_records")
> ### * check_quasiidentical_records
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_quasiidentical_records
> ### Title: Function checking the presence of quasi-identical records.
> ### Aliases: check_quasiidentical_records
> ### Keywords: quasi-identical
> 
> ### ** Examples
> 
> library(MEDITS)
> library(RoME)
> wd=tempdir()
> suffix= "27-02-2020 18:30"
> check_quasiidentical_records(TA,wd,suffix)
[1] FALSE
> check_quasiidentical_records(TB,wd,suffix)
Error in if (Err$YEAR[k] == Matrix2$YEAR[i]) { : 
  missing value where TRUE/FALSE needed
Calls: check_quasiidentical_records
Execution halted
